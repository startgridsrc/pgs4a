# -*- coding: utf-8 -*-
# Example app demonstrating resize, multitouch and playing sound.

import pygame, os, sys
from pygame.locals import *
try:
    import android
except ImportError:
    android = None
try:
    import pygame.mixer as mixer
except ImportError:
    import android.mixer as mixer


if android:
    from jnius import (autoclass, cast)
    try:
        api_level = autoclass('android.os.Build$VERSION').SDK_INT
    except: api_level = None
    android.init()
    android.map_key(android.KEYCODE_BACK, K_ESCAPE)
else:
    api_level = None # running on PC
    
_ = unicode(__file__, sys.getfilesystemencoding()).encode(sys.getfilesystemencoding())
PATH = os.path.dirname(os.path.abspath(_)) # where main.py is
PATH_ASSETS = os.path.join(PATH, 'assets')
os.chdir(PATH)
mixer.pre_init(22050, -16, 2, 2048)
pygame.init()


class Game():
    
    def __init__(self):
        self.delta = 0
        self.elapsed_time = 0
        self.screeninfo = pygame.display.Info()
        self.resize((self.screeninfo.current_w, self.screeninfo.current_h))
        self.framerate = 60
        self.clock_1 = pygame.time.Clock()
        self.sound_1 = mixer.Sound(os.path.join(PATH_ASSETS, 'sound_1.wav'))
        self.mouse_pos = (0, 0)
        self.mouse2_pos = None
        self.multi, self.multi2, self.touch1, self.touch2 = 0, 0, 0, 0

    def handle_inputs(self):
        if android and android.check_pause():
            android.wait_for_resume()
        for event in pygame.event.get():
            if android:
                result = self.check_multitouch(event)
                if isinstance(result, int) and result:
                    continue
                elif result:
                    self.mouse_pos, self.mouse2_pos = result
                    # do multitouch stuff here
                    continue
            if (event.type == MOUSEBUTTONDOWN):
                self.mouse_pos = event.pos
                self.sound_1.play()
            elif event.type == KEYDOWN:
                if event.key == K_ESCAPE:
                    self.stop()
            elif event.type == pygame.QUIT:
                self.stop()
            elif event.type == VIDEORESIZE:
                self.resize(event.size)

    def update(self):
        delta = self.clock_1.tick(self.framerate)
        self.elapsed_time += delta

    def render(self):
        self.screen.fill((0, 0, 50))
        self.screen.blit(self.font.render(str(self.mouse_pos),
                                          True, (255, 255, 0)), (0, 0))
        self.screen.blit(self.font.render(str(self.mouse2_pos),
                                          True, (0, 255, 0)), (0, self.font.size("")[1]))
        self.screen.blit(self.font.render("api " + str(api_level),
                                          True, (50, 50, 255)), (0, 2*self.font.size("")[1]))
        pygame.display.flip()

    def check_multitouch(self, event):
        """Multitouch is signalled by java using 4 mouse events,
            of which the positions are: (0,2), (2,0), touch1, touch2.
            The first two event positions are hard coded,
            but the next two events are the actual multitouch positions.
            This quircky way of serializing touch events gives us a way
            to detect that a (2-finger) multitouch event happened.
            As this takes 4 steps, we need to keep track of previous
            events by using the booleans multi and multi2.
            Returns two finger positions if we detect multitouch, but
            returns 1 the three steps before.
        """
        if event.type in (MOUSEBUTTONDOWN, MOUSEBUTTONUP, MOUSEMOTION):
            if event.type == MOUSEMOTION:
                if self.multi:
                    return 1 # ignore autogenerated mousemotion
            if event.pos == (1,1):
                self.multi = False
                self.multi2 = False
                self.touch1 = 0
                self.touch2 = 0
            if (event.pos == (0,2)) or (event.pos == (0,1)):
                # 1st hard coded event
                self.multi = True
                return 1
            elif self.multi and (event.pos == (2,0) or event.pos == (1,0)):
                # 2nd hard coded event
                self.multi2 = True
                self.touch1 = 0
                return 1
            elif self.multi2 and not self.touch1: # touch1
                self.touch1 = tuple(event.pos)
                return 1
            elif self.touch1: # touch2
                self.touch2 = tuple(event.pos)
            else: # not a multitouch, reset everything
                self.multi = False
                self.multi2 = False
                self.touch1 = 0
                self.touch2 = 0
            if self.touch2: # detected second touch
                touches = (self.touch1, self.touch2)
                self.multi = False
                self.multi2 = False
                self.touch1 = 0
                self.touch2 = 0
                return touches
        return 0

    def stop(self):
        pygame.quit()
        sys.exit()

    def resize(self, size):
        if android:
            self.screen = pygame.display.set_mode(size)
        else:
            self.screen = pygame.display.set_mode(size, RESIZABLE)
        self.font = pygame.font.Font(os.path.join(PATH_ASSETS, 'VeraBd.ttf'), size[0]/30)


def main():
    gm = Game()
    running = True
    while running:
        gm.handle_inputs()
        gm.update()
        gm.render()
    

if __name__ == "__main__":
    main()
